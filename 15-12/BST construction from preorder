//constructing a binary from a given preorder//
#include<iostream>
using namespace std;

class node {
  public:
  int key;
  node* left;
  node* right;
};

//function to create a node//
node* newNode(int k){
node* n =  new node();
n->key = k;
n->left = NULL;
n->right = NULL;
return n;
}

//function to create the tree
node* constructTreeUntil(int pre[],int* preIndex,int low,int high,int size){
  
  //base case//
  if(*preIndex >=size|| low>high)
  {
    return NULL;
  }
  //The first node in the preorder travesarl is root.so take the root node(1st node)and increment the preindex//
  node* root = newNode(pre[*preIndex]);
  *preIndex = *preIndex+1;

  //if the cureent sub array has only 1 element , no need to recur //
  if(low==high){
    return root;
  }

  //search for the 1st elememt greater than the root 
  int i;
  for (i = low;i<=high;++i)
  {
    if(pre[i]>root->key){
      break;
    }
  }
//use the index of the element found in the preorder to divide the preorder array into 2 parts .
root->left = constructTreeUntil(pre,preIndex,*preIndex,i-1,size);
root->right = constructTreeUntil(pre,preIndex,i,high,size);
return root;
}


//main function that uses the prevoius function//
node* constructTree(int pre[],int size){
  int preIndex = 0;
  return constructTreeUntil(pre, &preIndex, 0, size-1,size);
}

//the inorder traversal of the framed tree//
void inorder(node*n){
  if(n!=NULL){
    inorder(n->left);
    cout<<n->key;
    inorder(n->right);
  }
  else return;
}

//driver code 
int main()
{
  int pre[]= {10,5,1,7,40,50};
  int size = sizeof(pre) / sizeof(pre[0]);
 
    node* root = constructTree(pre, size);
 
    cout << "Inorder traversal of the constructed tree: \n";
    inorder(root);
 
    return 0;
}
